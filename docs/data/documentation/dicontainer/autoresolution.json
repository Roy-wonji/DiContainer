{"identifier":{"url":"doc:\/\/DiContainer\/documentation\/DiContainer\/AutoResolution","interfaceLanguage":"swift"},"primaryContentSections":[{"content":[{"anchor":"%EA%B0%9C%EC%9A%94","level":2,"type":"heading","text":"개요"},{"inlineContent":[{"text":"DiContainer의 자동 의존성 해결 시스템은 Swift의 Mirror API를 활용하여 런타임에 객체의 프로퍼티를 분석하고, ","type":"text"},{"code":"@Inject","type":"codeVoice"},{"text":" 프로퍼티 래퍼가 적용된 의존성들을 자동으로 해결합니다. 이를 통해 복잡한 의존성 그래프도 간단한 어노테이션만으로 관리할 수 있습니다.","type":"text"}],"type":"paragraph"},{"anchor":"AutoResolvable-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C","level":2,"type":"heading","text":"AutoResolvable 프로토콜"},{"anchor":"%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90","level":3,"type":"heading","text":"기본 개념"},{"inlineContent":[{"code":"AutoResolvable","type":"codeVoice"},{"text":" 프로토콜을 구현하면 해당 클래스의 ","type":"text"},{"code":"@Inject","type":"codeVoice"},{"text":" 프로퍼티들이 자동으로 해결됩니다.","type":"text"}],"type":"paragraph"},{"code":["import DiContainer","","\/\/ AutoResolvable 프로토콜 구현","class UserService: AutoResolvable {","    @Inject var repository: UserRepositoryProtocol?","    @Inject var logger: LoggingServiceProtocol?","    @Inject var cache: CacheServiceProtocol?","","    init() {","        \/\/ 자동 해결 시작","        AutoDependencyResolver.resolve(self)","    }","","    \/\/ 자동 해결 완료 시 호출되는 콜백","    public func didAutoResolve() {","        print(\"✅ UserService 자동 해결 완료\")","        logger?.log(\"UserService가 모든 의존성과 함께 초기화되었습니다\", level: .info)","    }","","    func getUserById(_ id: String) async throws -> User {","        logger?.log(\"사용자 조회 시작: \\(id)\", level: .info)","","        guard let repository = repository else {","            throw ServiceError.dependencyNotResolved(\"UserRepository\")","        }","","        let user = try await repository.fetchUser(id: id)","        cache?.set(user, forKey: \"user_\\(id)\")","","        return user","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"%EA%B3%A0%EA%B8%89-%EC%9E%90%EB%8F%99-%ED%95%B4%EA%B2%B0-%ED%8C%A8%ED%84%B4","level":3,"type":"heading","text":"고급 자동 해결 패턴"},{"code":["\/\/ 복잡한 의존성을 가진 서비스","class NotificationManager: AutoResolvable {","    @Inject var notificationService: NotificationServiceProtocol?","    @Inject var userService: UserService?","    @Inject var templateEngine: TemplateEngineProtocol?","    @Inject var logger: LoggingServiceProtocol?","","    private var resolvedDependencies: [String] = []","","    init() {","        \/\/ 비동기 자동 해결 사용","        Task {","            await AutoDependencyResolver.resolveAsync(self)","        }","    }","","    public func didAutoResolve() {","        print(\"✅ NotificationManager 자동 해결 완료\")","        logger?.log(\"NotificationManager 준비됨\", level: .info)","","        \/\/ 해결된 의존성들 확인","        validateDependencies()","    }","","    private func validateDependencies() {","        if notificationService != nil { resolvedDependencies.append(\"NotificationService\") }","        if userService != nil { resolvedDependencies.append(\"UserService\") }","        if templateEngine != nil { resolvedDependencies.append(\"TemplateEngine\") }","        if logger != nil { resolvedDependencies.append(\"Logger\") }","","        logger?.log(\"해결된 의존성들: \\(resolvedDependencies.joined(separator: \", \"))\", level: .debug)","    }","","    func sendUserNotification(userId: String, templateId: String, data: [String: Any]) async throws {","        logger?.log(\"사용자 알림 전송 시작: \\(userId)\", level: .info)","","        guard let notificationService = notificationService else {","            throw ServiceError.dependencyNotResolved(\"NotificationService\")","        }","","        guard let templateEngine = templateEngine else {","            throw ServiceError.dependencyNotResolved(\"TemplateEngine\")","        }","","        let template = templateEngine.renderTemplate(templateId, with: data)","        try await notificationService.send(template, to: userId)","","        logger?.log(\"알림 전송 완료\", level: .info)","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"AutoDependencyResolver-%ED%95%B5%EC%8B%AC-%ED%95%B4%EA%B2%B0%EC%9E%90","level":2,"type":"heading","text":"AutoDependencyResolver - 핵심 해결자"},{"anchor":"%EA%B8%B0%EB%B3%B8-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95","level":3,"type":"heading","text":"기본 해결 방법"},{"code":["\/\/ 동기 자동 해결","class SyncService: AutoResolvable {","    @Inject var dependency: SomeDependencyProtocol?","","    init() {","        AutoDependencyResolver.resolve(self)","    }","","    func didAutoResolve() {","        print(\"동기 해결 완료\")","    }","}","","\/\/ 비동기 자동 해결","class AsyncService: AutoResolvable {","    @Inject var heavyDependency: HeavyDependencyProtocol?","","    init() {","        Task {","            await AutoDependencyResolver.resolveAsync(self)","        }","    }","","    func didAutoResolve() {","        print(\"비동기 해결 완료\")","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"%EC%A0%84%EC%97%AD-%EC%84%A4%EC%A0%95%EA%B3%BC-%EC%A0%9C%EC%96%B4","level":3,"type":"heading","text":"전역 설정과 제어"},{"code":["\/\/ 자동 해결 시스템 전역 제어","class AutoResolutionConfiguration {","    static func setupAutoResolution() {","        \/\/ 자동 해결 활성화","        AutoDependencyResolver.enable()","","        \/\/ 특정 타입을 자동 해결에서 제외","        AutoDependencyResolver.excludeType(LegacyService.self)","        AutoDependencyResolver.excludeType(ManualService.self)","","        \/\/ 성능상의 이유로 무거운 타입들 제외","        AutoDependencyResolver.excludeType(MachineLearningService.self)","        AutoDependencyResolver.excludeType(VideoProcessingService.self)","    }","","    static func disableAutoResolutionForTesting() {","        \/\/ 테스트에서는 자동 해결 비활성화하여 명시적 제어","        AutoDependencyResolver.disable()","    }","","    static func enableSelectiveAutoResolution() {","        \/\/ 선택적으로 특정 타입들만 자동 해결","        AutoDependencyResolver.disable()","        AutoDependencyResolver.includeType(UserService.self)","        AutoDependencyResolver.includeType(NotificationService.self)","        AutoDependencyResolver.enable()","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"%ED%83%80%EC%9E%85%EB%B3%84-%EC%9D%BC%EA%B4%84-%ED%95%B4%EA%B2%B0","level":3,"type":"heading","text":"타입별 일괄 해결"},{"code":["\/\/ 특정 타입의 모든 인스턴스에 대해 자동 해결 수행","class AutoResolutionManager {","    static func refreshAllUserServices() {","        \/\/ 이미 생성된 UserService 인스턴스들을 모두 재해결","        AutoDependencyResolver.resolveAllInstances(of: UserService.self)","        print(\"🔄 모든 UserService 인스턴스 재해결 완료\")","    }","","    static func refreshAllServicesAfterConfigChange() {","        \/\/ 설정 변경 후 모든 서비스 재해결","        AutoDependencyResolver.resolveAllInstances(of: UserService.self)","        AutoDependencyResolver.resolveAllInstances(of: NotificationService.self)","        AutoDependencyResolver.resolveAllInstances(of: AnalyticsService.self)","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"AutoInjectible-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%88%98%EB%8F%99-%EC%A3%BC%EC%9E%85-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4","level":2,"type":"heading","text":"AutoInjectible 프로토콜 - 수동 주입 인터페이스"},{"anchor":"%EA%B8%B0%EB%B3%B8-%EC%82%AC%EC%9A%A9%EB%B2%95","level":3,"type":"heading","text":"기본 사용법"},{"inlineContent":[{"text":"Swift의 리플렉션 한계로 인해 일부 시나리오에서는 수동 주입이 필요합니다.","type":"text"}],"type":"paragraph"},{"code":["class AdvancedService: AutoResolvable, AutoInjectible {","    @Inject var repository: UserRepositoryProtocol?","    @Inject var logger: LoggingServiceProtocol?","","    private var customDependencies: [String: Any] = [:]","","    init() {","        AutoDependencyResolver.resolve(self)","    }","","    \/\/ AutoInjectible 구현 - 수동 주입 처리","    public func injectResolvedValue(_ value: Any, forProperty propertyName: String) {","        customDependencies[propertyName] = value","","        \/\/ 타입별 수동 주입 처리","        switch propertyName {","        case \"repository\":","            if let repo = value as? UserRepositoryProtocol {","                print(\"🔧 UserRepository 주입됨\")","                \/\/ 추가 초기화 로직","                setupRepositoryConnection(repo)","            }","","        case \"logger\":","            if let logger = value as? LoggingServiceProtocol {","                print(\"🔧 Logger 주입됨\")","                logger.log(\"AdvancedService 초기화 시작\", level: .info)","            }","","        default:","            print(\"⚠️ 알려지지 않은 프로퍼티: \\(propertyName)\")","        }","    }","","    public func didAutoResolve() {","        print(\"✅ AdvancedService 자동 해결 완료\")","        print(\"주입된 의존성들: \\(customDependencies.keys.joined(separator: \", \"))\")","    }","","    private func setupRepositoryConnection(_ repository: UserRepositoryProtocol) {","        \/\/ Repository별 초기 설정","        Task {","            await repository.initialize()","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"%EC%A1%B0%EA%B1%B4%EB%B6%80-%EC%9E%90%EB%8F%99-%ED%95%B4%EA%B2%B0","level":3,"type":"heading","text":"조건부 자동 해결"},{"code":["class ConditionalService: AutoResolvable {","    @Inject var analyticsService: AnalyticsServiceProtocol?","    @Inject var logger: LoggingServiceProtocol?","","    private let isAnalyticsEnabled: Bool","","    init(enableAnalytics: Bool = true) {","        self.isAnalyticsEnabled = enableAnalytics","","        \/\/ 조건부 자동 해결","        if isAnalyticsEnabled {","            AutoDependencyResolver.resolve(self)","        } else {","            \/\/ 분석 서비스 없이 제한된 해결","            resolveEssentialDependenciesOnly()","        }","    }","","    private func resolveEssentialDependenciesOnly() {","        \/\/ 필수 의존성만 수동으로 해결","        logger = DI.resolve(LoggingServiceProtocol.self)","        print(\"필수 의존성만 해결됨\")","    }","","    func didAutoResolve() {","        if isAnalyticsEnabled {","            logger?.log(\"분석 기능이 활성화된 ConditionalService 초기화 완료\", level: .info)","        }","    }","","    func performOperation() {","        logger?.log(\"작업 수행 중\", level: .info)","","        if isAnalyticsEnabled {","            analyticsService?.track(event: \"operation_performed\")","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"%EC%84%B1%EB%8A%A5-%EC%B6%94%EC%A0%81%EA%B3%BC-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81","level":2,"type":"heading","text":"성능 추적과 모니터링"},{"anchor":"%EC%9E%90%EB%8F%99-%ED%95%B4%EA%B2%B0-%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95","level":3,"type":"heading","text":"자동 해결 성능 측정"},{"code":["class PerformanceTrackedService: AutoResolvable {","    @Inject var service1: Service1Protocol?","    @Inject var service2: Service2Protocol?","    @Inject var service3: Service3Protocol?","","    init() {","        let startTime = CFAbsoluteTimeGetCurrent()","","        AutoDependencyResolver.resolve(self)","","        let endTime = CFAbsoluteTimeGetCurrent()","        let resolutionTime = (endTime - startTime) * 1000 \/\/ ms","","        print(\"🔄 자동 해결 시간: \\(String(format: \"%.2f\", resolutionTime))ms\")","    }","","    func didAutoResolve() {","        print(\"성능 추적 완료\")","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%8F%99-%ED%95%B4%EA%B2%B0","level":3,"type":"heading","text":"성능 최적화를 위한 자동 해결"},{"code":["class OptimizedAutoService: AutoResolvable {","    @Inject var criticalService: CriticalServiceProtocol?","    @Inject var backgroundService: BackgroundServiceProtocol?","","    \/\/ 지연 로딩으로 필요시에만 해결","    @Inject lazy var heavyService: HeavyServiceProtocol?","","    init() {","        \/\/ 성능 추적과 함께 자동 해결","        AutoDependencyResolver.resolveWithPerformanceTracking(self)","    }","","    func didAutoResolve() {","        \/\/ 중요한 서비스만 즉시 검증","        validateCriticalDependencies()","    }","","    private func validateCriticalDependencies() {","        guard criticalService != nil else {","            fatalError(\"CriticalService는 반드시 필요합니다\")","        }","","        \/\/ 백그라운드 서비스는 선택적","        if backgroundService == nil {","            print(\"⚠️ BackgroundService를 사용할 수 없습니다. 제한된 기능으로 실행됩니다.\")","        }","    }","","    func performHeavyOperation() async {","        \/\/ 실제 사용 시점에 heavy service 해결","        guard let heavyService = heavyService else {","            throw ServiceError.dependencyNotResolved(\"HeavyService\")","        }","","        await heavyService.performIntensiveWork()","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9-%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4","level":2,"type":"heading","text":"실제 사용 시나리오"},{"anchor":"MVVM-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%97%90%EC%84%9C%EC%9D%98-%ED%99%9C%EC%9A%A9","level":3,"type":"heading","text":"MVVM 아키텍처에서의 활용"},{"code":["@MainActor","class UserProfileViewModel: AutoResolvable, ObservableObject {","    @Published var user: User?","    @Published var isLoading = false","    @Published var errorMessage: String?","","    @Inject var userService: UserServiceProtocol?","    @Inject var imageService: ImageServiceProtocol?","    @Inject var logger: LoggingServiceProtocol?","","    init() {","        AutoDependencyResolver.resolve(self)","    }","","    func didAutoResolve() {","        logger?.log(\"UserProfileViewModel 초기화 완료\", level: .info)","","        \/\/ 의존성 확인","        if userService == nil {","            logger?.error(\"UserService를 사용할 수 없습니다\")","        }","        if imageService == nil {","            logger?.warning(\"ImageService를 사용할 수 없습니다. 이미지 기능이 제한됩니다\")","        }","    }","","    func loadUserProfile(userId: String) async {","        isLoading = true","        errorMessage = nil","","        do {","            guard let userService = userService else {","                throw ViewModelError.serviceUnavailable(\"UserService\")","            }","","            let loadedUser = try await userService.getUser(id: userId)","            self.user = loadedUser","","            \/\/ 프로필 이미지 미리 로드","            if let imageService = imageService {","                await imageService.preloadImage(url: loadedUser.profileImageURL)","            }","","            logger?.log(\"사용자 프로필 로드 완료: \\(loadedUser.name)\", level: .info)","","        } catch {","            self.errorMessage = error.localizedDescription","            logger?.error(\"사용자 프로필 로드 실패: \\(error)\")","        }","","        isLoading = false","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Clean-Architecture%EC%97%90%EC%84%9C%EC%9D%98-%ED%99%9C%EC%9A%A9","level":3,"type":"heading","text":"Clean Architecture에서의 활용"},{"code":["\/\/ Domain Layer - UseCase","class GetUserUseCase: AutoResolvable {","    @Inject var userRepository: UserRepositoryProtocol?","    @Inject var logger: LoggingServiceProtocol?","","    init() {","        AutoDependencyResolver.resolve(self)","    }","","    func didAutoResolve() {","        logger?.log(\"GetUserUseCase 준비 완료\", level: .debug)","    }","","    func execute(userId: String) async throws -> User {","        logger?.debug(\"사용자 조회 UseCase 실행: \\(userId)\")","","        guard let repository = userRepository else {","            throw UseCaseError.repositoryNotAvailable","        }","","        return try await repository.findUser(by: userId)","    }","}","","\/\/ Presentation Layer - Presenter","class UserPresenter: AutoResolvable {","    @Inject var getUserUseCase: GetUserUseCase?","    @Inject var updateUserUseCase: UpdateUserUseCase?","    @Inject var logger: LoggingServiceProtocol?","","    weak var view: UserViewProtocol?","","    init(view: UserViewProtocol) {","        self.view = view","        AutoDependencyResolver.resolve(self)","    }","","    func didAutoResolve() {","        logger?.log(\"UserPresenter 초기화 완료\", level: .debug)","        validateUseCases()","    }","","    private func validateUseCases() {","        if getUserUseCase == nil {","            logger?.error(\"GetUserUseCase를 사용할 수 없습니다\")","        }","        if updateUserUseCase == nil {","            logger?.warning(\"UpdateUserUseCase를 사용할 수 없습니다\")","        }","    }","","    func loadUser(id: String) {","        Task {","            view?.showLoading(true)","","            do {","                guard let useCase = getUserUseCase else {","                    throw PresenterError.useCaseNotAvailable","                }","","                let user = try await useCase.execute(userId: id)","                await MainActor.run {","                    view?.showUser(user)","                    view?.showLoading(false)","                }","","            } catch {","                await MainActor.run {","                    view?.showError(error.localizedDescription)","                    view?.showLoading(false)","                }","                logger?.error(\"사용자 로드 실패: \\(error)\")","            }","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C%EC%9D%98-%EC%9E%90%EB%8F%99-%ED%95%B4%EA%B2%B0","level":2,"type":"heading","text":"테스트에서의 자동 해결"},{"anchor":"Mock-%EC%9E%90%EB%8F%99-%EC%A3%BC%EC%9E%85","level":3,"type":"heading","text":"Mock 자동 주입"},{"code":["class UserServiceTests: XCTestCase {","    var mockRepository: MockUserRepository!","    var mockLogger: MockLogger!","    var userService: UserService!","","    override func setUp() async throws {","        await super.setUp()","","        \/\/ Mock 객체들 생성","        mockRepository = MockUserRepository()","        mockLogger = MockLogger()","","        \/\/ Mock들을 DI 컨테이너에 등록","        DI.register(UserRepositoryProtocol.self, instance: mockRepository)","        DI.register(LoggingServiceProtocol.self, instance: mockLogger)","","        \/\/ 테스트 대상 생성 (자동으로 Mock들이 주입됨)","        userService = UserService()","    }","","    func testAutoInjectedMocks() {","        \/\/ 자동 주입이 제대로 되었는지 확인","        XCTAssertNotNil(userService.repository)","        XCTAssertNotNil(userService.logger)","","        \/\/ Mock 인스턴스가 정확히 주입되었는지 확인","        XCTAssertTrue(userService.repository is MockUserRepository)","        XCTAssertTrue(userService.logger is MockLogger)","    }","","    func testUserServiceWithAutoResolvedMocks() async throws {","        \/\/ Given","        let expectedUser = User(id: \"test\", name: \"Test User\")","        mockRepository.mockUser = expectedUser","","        \/\/ When","        let user = try await userService.getUserById(\"test\")","","        \/\/ Then","        XCTAssertEqual(user.id, expectedUser.id)","        XCTAssertEqual(user.name, expectedUser.name)","        XCTAssertTrue(mockLogger.loggedMessages.contains { $0.contains(\"사용자 조회\") })","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"%EC%9E%90%EB%8F%99-%ED%95%B4%EA%B2%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8","level":3,"type":"heading","text":"자동 해결 시스템 테스트"},{"code":["class AutoResolutionSystemTests: XCTestCase {","","    func testAutoResolutionEnabled() {","        \/\/ Given","        AutoDependencyResolver.enable()","","        class TestService: AutoResolvable {","            @Inject var dependency: TestDependencyProtocol?","            var wasAutoResolved = false","","            func didAutoResolve() {","                wasAutoResolved = true","            }","        }","","        DI.register(TestDependencyProtocol.self) { MockTestDependency() }","","        \/\/ When","        let service = TestService()","        AutoDependencyResolver.resolve(service)","","        \/\/ Then","        XCTAssertNotNil(service.dependency)","        XCTAssertTrue(service.wasAutoResolved)","    }","","    func testAutoResolutionDisabled() {","        \/\/ Given","        AutoDependencyResolver.disable()","","        class TestService: AutoResolvable {","            @Inject var dependency: TestDependencyProtocol?","            var wasAutoResolved = false","","            func didAutoResolve() {","                wasAutoResolved = true","            }","        }","","        DI.register(TestDependencyProtocol.self) { MockTestDependency() }","","        \/\/ When","        let service = TestService()","        AutoDependencyResolver.resolve(service)","","        \/\/ Then","        XCTAssertNil(service.dependency) \/\/ 비활성화되어 있으므로 주입되지 않음","        XCTAssertFalse(service.wasAutoResolved)","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD%EA%B3%BC-%EB%AA%A8%EB%B2%94-%EC%82%AC%EB%A1%80","level":2,"type":"heading","text":"주의사항과 모범 사례"},{"anchor":"%EC%84%B1%EB%8A%A5-%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD","level":3,"type":"heading","text":"성능 고려사항"},{"code":["\/\/ ✅ 좋은 예: 선택적 자동 해결","class OptimalService: AutoResolvable {","    @Inject var essentialService: EssentialServiceProtocol?","","    \/\/ 무거운 의존성은 lazy loading","    @Inject lazy var heavyService: HeavyServiceProtocol?","","    init() {","        \/\/ 필수 의존성만 즉시 해결","        AutoDependencyResolver.resolve(self)","    }","","    func didAutoResolve() {","        \/\/ 필수 의존성 검증만 수행","        guard essentialService != nil else {","            fatalError(\"필수 서비스가 주입되지 않았습니다\")","        }","    }","}","","\/\/ ❌ 피해야 할 예: 모든 것을 즉시 해결","class SuboptimalService: AutoResolvable {","    @Inject var service1: Service1Protocol?","    @Inject var service2: Service2Protocol?","    \/\/ ... 20개의 서비스들","    @Inject var service20: Service20Protocol?","","    init() {","        \/\/ 모든 의존성을 즉시 해결 (성능 저하)","        AutoDependencyResolver.resolve(self)","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"%EC%88%9C%ED%99%98-%EC%9D%98%EC%A1%B4%EC%84%B1-%EB%B0%A9%EC%A7%80","level":3,"type":"heading","text":"순환 의존성 방지"},{"code":["\/\/ ✅ 좋은 예: 인터페이스 분리로 순환 의존성 방지","protocol ServiceADelegate {","    func handleEvent(_ event: String)","}","","class ServiceA: AutoResolvable, ServiceADelegate {","    @Inject var serviceB: ServiceBProtocol?","","    func didAutoResolve() {","        serviceB?.setDelegate(self)","    }","","    func handleEvent(_ event: String) {","        print(\"Event handled: \\(event)\")","    }","}","","class ServiceB: ServiceBProtocol {","    weak var delegate: ServiceADelegate?","","    func setDelegate(_ delegate: ServiceADelegate) {","        self.delegate = delegate","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"DiContainer의 자동 의존성 해결 시스템은 복잡한 의존성 그래프를 단순하게 관리할 수 있게 해주는 강력한 도구입니다. 적절히 사용하면 코드의 간결성과 유지보수성을 크게 향상시킬 수 있습니다.","type":"text"}],"type":"paragraph"}],"kind":"content"}],"variants":[{"paths":["\/documentation\/dicontainer\/autoresolution"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/DiContainer\/documentation\/DiContainer"]]},"metadata":{"roleHeading":"Article","modules":[{"name":"DiContainer"}],"role":"article","title":"자동 의존성 해결"},"abstract":[{"type":"text","text":"DiContainer의 강력한 자동 의존성 해결 시스템을 활용하여 리플렉션 기반의 자동 주입을 구현하는 방법"}],"sections":[],"kind":"article","seeAlsoSections":[{"generated":true,"title":"고급 기능","identifiers":["doc:\/\/DiContainer\/documentation\/DiContainer\/AutoDependencyResolver","doc:\/\/DiContainer\/documentation\/DiContainer\/PluginSystem","doc:\/\/DiContainer\/documentation\/DiContainer\/BasePlugin","doc:\/\/DiContainer\/documentation\/DiContainer\/ModuleFactory","doc:\/\/DiContainer\/documentation\/DiContainer\/RepositoryModuleFactory","doc:\/\/DiContainer\/documentation\/DiContainer\/UseCaseModuleFactory","doc:\/\/DiContainer\/documentation\/DiContainer\/ScopeModuleFactory"],"anchor":"고급-기능"}],"schemaVersion":{"patch":0,"minor":3,"major":0},"references":{"doc://DiContainer/documentation/DiContainer/RepositoryModuleFactory":{"title":"RepositoryModuleFactory","identifier":"doc:\/\/DiContainer\/documentation\/DiContainer\/RepositoryModuleFactory","url":"\/documentation\/dicontainer\/repositorymodulefactory","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RepositoryModuleFactory","kind":"identifier"}],"navigatorTitle":[{"text":"RepositoryModuleFactory","kind":"identifier"}],"abstract":[{"type":"text","text":"Repository 계층 모듈 팩토리"}],"kind":"symbol","role":"symbol"},"doc://DiContainer/documentation/DiContainer/UseCaseModuleFactory":{"url":"\/documentation\/dicontainer\/usecasemodulefactory","kind":"symbol","type":"topic","navigatorTitle":[{"text":"UseCaseModuleFactory","kind":"identifier"}],"title":"UseCaseModuleFactory","role":"symbol","identifier":"doc:\/\/DiContainer\/documentation\/DiContainer\/UseCaseModuleFactory","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"UseCaseModuleFactory"}],"abstract":[{"text":"UseCase 계층 모듈 팩토리","type":"text"}]},"doc://DiContainer/documentation/DiContainer/AutoDependencyResolver":{"title":"AutoDependencyResolver","identifier":"doc:\/\/DiContainer\/documentation\/DiContainer\/AutoDependencyResolver","url":"\/documentation\/dicontainer\/autodependencyresolver","type":"topic","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AutoDependencyResolver","kind":"identifier"}],"navigatorTitle":[{"text":"AutoDependencyResolver","kind":"identifier"}],"abstract":[{"type":"text","text":"자동 의존성 해결을 수행하는 핵심 클래스 (메인 액터 격리)"}],"kind":"symbol","role":"symbol"},"doc://DiContainer/documentation/DiContainer/ModuleFactory":{"identifier":"doc:\/\/DiContainer\/documentation\/DiContainer\/ModuleFactory","url":"\/documentation\/dicontainer\/modulefactory","title":"Module Factory","type":"topic","abstract":[{"text":"팩토리로 모듈을 체계적으로 생성하고 Container에 등록합니다.","type":"text"}],"kind":"article","role":"article"},"doc://DiContainer/documentation/DiContainer/BasePlugin":{"title":"BasePlugin","url":"\/documentation\/dicontainer\/baseplugin","identifier":"doc:\/\/DiContainer\/documentation\/DiContainer\/BasePlugin","type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"BasePlugin"}],"navigatorTitle":[{"kind":"identifier","text":"BasePlugin"}],"abstract":[{"type":"text","text":"기본 플러그인 구현을 위한 베이스 클래스"}],"kind":"symbol","role":"symbol"},"doc://DiContainer/documentation/DiContainer/ScopeModuleFactory":{"title":"ScopeModuleFactory","identifier":"doc:\/\/DiContainer\/documentation\/DiContainer\/ScopeModuleFactory","url":"\/documentation\/dicontainer\/scopemodulefactory","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ScopeModuleFactory","kind":"identifier"}],"navigatorTitle":[{"text":"ScopeModuleFactory","kind":"identifier"}],"abstract":[{"type":"text","text":"Scope 계층 모듈 팩토리"}],"kind":"symbol","role":"symbol"},"doc://DiContainer/documentation/DiContainer":{"url":"\/documentation\/dicontainer","role":"collection","type":"topic","abstract":[{"text":"현대적인 Swift Concurrency와 Actor 모델을 위해 설계된 고성능 의존성 주입 프레임워크","type":"text"}],"title":"DiContainer","identifier":"doc:\/\/DiContainer\/documentation\/DiContainer","kind":"symbol"},"doc://DiContainer/documentation/DiContainer/PluginSystem":{"identifier":"doc:\/\/DiContainer\/documentation\/DiContainer\/PluginSystem","url":"\/documentation\/dicontainer\/pluginsystem","title":"플러그인 시스템","type":"topic","abstract":[{"text":"DiContainer의 강력한 플러그인 아키텍처를 사용하여 의존성 주입 과정을 커스터마이징하고 확장하는 방법","type":"text"}],"kind":"article","role":"article"}}}