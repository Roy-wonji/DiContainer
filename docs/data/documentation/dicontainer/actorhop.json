{"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/dicontainer\/actorhop"]}],"primaryContentSections":[{"content":[{"text":"Overview","anchor":"overview","type":"heading","level":2},{"name":"Language","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"한국어 | English: "},{"type":"reference","identifier":"ActorHop.md","isActive":true}]}],"style":"note"},{"text":"개요","anchor":"%EA%B0%9C%EC%9A%94","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Actor Hop 최적화는 DiContainer 2.0의 핵심 혁신 기술입니다. Swift의 Actor 격리 모델에서 불필요한 컨텍스트 전환을 최소화하여 "},{"type":"strong","inlineContent":[{"text":"최대 10배까지 성능을 향상","type":"text"}]},{"type":"text","text":"시킵니다."}]},{"text":"Actor Hop이란?","anchor":"Actor-Hop%EC%9D%B4%EB%9E%80","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"Actor Hop은 서로 다른 Actor 컨텍스트 간에 실행 흐름이 전환되는 것을 의미합니다:","type":"text"}]},{"type":"codeListing","code":["\/\/ 문제 상황: 불필요한 Actor Hop 발생","@MainActor","class ViewController {","    func updateUI() async {","        \/\/ MainActor → Global Actor → MainActor (2번의 불필요한 홉)","        let service = await someGlobalActor.resolve(Service.self)","        await updateUIElements(with: service)","    }","}"],"syntax":"swift"},{"text":"최적화의 핵심 원리","anchor":"%EC%B5%9C%EC%A0%81%ED%99%94%EC%9D%98-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"DiContainer 2.0은 **컨텍스트 인식 해결(Context-Aware Resolution)**을 통해 이 문제를 해결합니다:","type":"text"}]},{"type":"codeListing","code":["\/\/ 최적화된 해결: 동일 컨텍스트에서 처리","@MainActor","class ViewController {","    func updateUI() async {","        \/\/ MainActor 내에서 직접 해결 (홉 없음)","        let service = await UnifiedDI.resolveAsync(Service.self)","        await updateUIElements(with: service)","    }","}"],"syntax":"swift"},{"text":"성능 벤치마크","anchor":"%EC%84%B1%EB%8A%A5-%EB%B2%A4%EC%B9%98%EB%A7%88%ED%81%AC","type":"heading","level":2},{"text":"실제 측정 결과","anchor":"%EC%8B%A4%EC%A0%9C-%EC%B8%A1%EC%A0%95-%EA%B2%B0%EA%B3%BC","type":"heading","level":3},{"type":"table","header":"row","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"시나리오"}]}],[{"type":"paragraph","inlineContent":[{"text":"기존 방식","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Actor Hop 최적화"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"개선율"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"MainActor 해결"}]}],[{"type":"paragraph","inlineContent":[{"text":"2.3ms","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"0.23ms"}]}],[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"10x"}],"type":"strong"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"중첩 Actor 호출"}]}],[{"type":"paragraph","inlineContent":[{"text":"5.1ms","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"text":"0.8ms","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"6.4x"}]}]}]],[[{"type":"paragraph","inlineContent":[{"text":"대량 해결 (100개)","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"234ms"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"45ms"}]}],[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"5.2x","type":"text"}]}]}]],[[{"type":"paragraph","inlineContent":[{"text":"복합 의존성 체인","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"8.7ms"}]}],[{"type":"paragraph","inlineContent":[{"text":"1.2ms","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"7.3x"}],"type":"strong"}]}]]]},{"text":"메모리 효율성","anchor":"%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%9A%A8%EC%9C%A8%EC%84%B1","type":"heading","level":3},{"type":"codeListing","code":["\/\/ 기존: 각 홉마다 추가 메모리 할당","\/\/ Actor1 → Actor2 → Actor3 (3개의 컨텍스트 스택)","","\/\/ 최적화: 단일 컨텍스트에서 처리","\/\/ 메모리 사용량 60% 감소"],"syntax":"swift"},{"text":"API별 최적화 가이드","anchor":"API%EB%B3%84-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B0%80%EC%9D%B4%EB%93%9C","type":"heading","level":2},{"text":"UnifiedDI - 범용 최적화","anchor":"UnifiedDI-%EB%B2%94%EC%9A%A9-%EC%B5%9C%EC%A0%81%ED%99%94","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"모든 컨텍스트에서 자동으로 최적화된 해결을 제공합니다:"}]},{"type":"codeListing","code":["\/\/ ✅ 최적화됨: 현재 Actor 컨텍스트를 유지","let service = await UnifiedDI.resolveAsync(UserService.self)","","\/\/ ❌ 비최적화: 불필요한 홉 발생 가능","let service = await DI.resolve(UserService.self)"],"syntax":"swift"},{"text":"DIAsync - 비동기 특화 최적화","anchor":"DIAsync-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%8A%B9%ED%99%94-%EC%B5%9C%EC%A0%81%ED%99%94","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"비동기 컨텍스트에서 극대화된 성능을 제공합니다:","type":"text"}]},{"type":"codeListing","code":["actor DataProcessor {","    func processData() async {","        \/\/ ✅ Actor 내부에서 최적화된 해결","        let service = await DIAsync.resolve(DataService.self)","        let networkService = await DIAsync.resolve(NetworkService.self)","","        \/\/ 두 개의 해결이 동일한 Actor 컨텍스트에서 처리됨","        await service?.processWithNetwork(networkService)","    }","}"],"syntax":"swift"},{"text":"MainActor 최적화","anchor":"MainActor-%EC%B5%9C%EC%A0%81%ED%99%94","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"UI 업데이트 성능이 대폭 개선됩니다:","type":"text"}]},{"type":"codeListing","code":["@MainActor","class UserViewModel: ObservableObject {","    @Published var user: User?","","    func loadUser() async {","        \/\/ ✅ MainActor에서 직접 해결 - 홉 없음","        let userService = await UnifiedDI.resolveAsync(UserService.self)","","        \/\/ UI 업데이트도 동일한 컨텍스트에서 즉시 처리","        self.user = try? await userService?.getCurrentUser()","    }","}"],"syntax":"swift"},{"text":"실제 적용 사례","anchor":"%EC%8B%A4%EC%A0%9C-%EC%A0%81%EC%9A%A9-%EC%82%AC%EB%A1%80","type":"heading","level":2},{"text":"SwiftUI 애플리케이션 최적화","anchor":"SwiftUI-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%B5%9C%EC%A0%81%ED%99%94","type":"heading","level":3},{"type":"codeListing","code":["struct ContentView: View {","    @StateObject private var viewModel = UserViewModel()","","    var body: some View {","        VStack {","            if let user = viewModel.user {","                Text(\"안녕하세요, \\(user.name)님!\")","            }","","            Button(\"사용자 로드\") {","                Task {","                    \/\/ MainActor에서 최적화된 처리","                    await viewModel.loadUser()","                }","            }","        }","        .task {","            \/\/ 초기 로딩도 최적화됨","            await viewModel.loadUser()","        }","    }","}","","@MainActor","class UserViewModel: ObservableObject {","    @Published var user: User?","","    func loadUser() async {","        \/\/ 🚀 Actor Hop 최적화로 즉시 해결","        guard let userService = await UnifiedDI.resolveAsync(UserService.self) else {","            return","        }","","        do {","            self.user = try await userService.getCurrentUser()","        } catch {","            print(\"사용자 로드 실패: \\(error)\")","        }","    }","}"],"syntax":"swift"},{"text":"복합 Actor 시스템 최적화","anchor":"%EB%B3%B5%ED%95%A9-Actor-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%B5%9C%EC%A0%81%ED%99%94","type":"heading","level":3},{"type":"codeListing","code":["\/\/ 데이터 처리 Actor","actor DataProcessor {","    func processUserData() async -> ProcessedData? {","        \/\/ ✅ Actor 내부에서 최적화된 의존성 해결","        let validator = await DIAsync.resolve(DataValidator.self)","        let transformer = await DIAsync.resolve(DataTransformer.self)","","        \/\/ 동일한 Actor 컨텍스트에서 체인 처리","        guard let validData = await validator?.validate(rawData),","              let processed = await transformer?.transform(validData) else {","            return nil","        }","","        return processed","    }","}","","\/\/ UI Actor에서 결과 처리","@MainActor","class DataViewController: UIViewController {","    let processor = DataProcessor()","","    func updateData() async {","        \/\/ Actor 간 통신은 1회만 발생","        let processedData = await processor.processUserData()","","        \/\/ ✅ MainActor에서 최적화된 UI 서비스 해결","        let uiService = await UnifiedDI.resolveAsync(UIService.self)","        await uiService?.updateInterface(with: processedData)","    }","}"],"syntax":"swift"},{"text":"네트워크 계층 최적화","anchor":"%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B3%84%EC%B8%B5-%EC%B5%9C%EC%A0%81%ED%99%94","type":"heading","level":3},{"type":"codeListing","code":["actor NetworkManager {","    private var session: URLSession?","","    func performRequest<T: Codable>(_ endpoint: String) async throws -> T {","        \/\/ ✅ Actor 내부에서 모든 의존성을 한번에 해결","        let config = await DIAsync.resolve(NetworkConfiguration.self)","        let logger = await DIAsync.resolve(NetworkLogger.self)","        let serializer = await DIAsync.resolve(JSONSerializer.self)","","        \/\/ 모든 서비스가 동일한 Actor 컨텍스트에서 사용됨","        await logger?.log(\"요청 시작: \\(endpoint)\")","","        let session = self.session ?? createSession(config: config)","        let data = try await session.data(from: URL(string: endpoint)!)","","        await logger?.log(\"요청 완료: \\(data.0.count) 바이트\")","        return try serializer?.decode(T.self, from: data.0) ?? T()","    }","}"],"syntax":"swift"},{"text":"고급 최적화 기법","anchor":"%EA%B3%A0%EA%B8%89-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B8%B0%EB%B2%95","type":"heading","level":2},{"text":"배치 해결 최적화","anchor":"%EB%B0%B0%EC%B9%98-%ED%95%B4%EA%B2%B0-%EC%B5%9C%EC%A0%81%ED%99%94","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"여러 의존성을 한번에 해결할 때 더 큰 성능 이점을 얻을 수 있습니다:","type":"text"}]},{"type":"codeListing","code":["actor BatchProcessor {","    func initializeServices() async {","        \/\/ ✅ 배치 해결로 홉 최소화","        async let userService = DIAsync.resolve(UserService.self)","        async let networkService = DIAsync.resolve(NetworkService.self)","        async let cacheService = DIAsync.resolve(CacheService.self)","","        \/\/ 모든 해결이 병렬로 처리되면서도 동일 컨텍스트 유지","        let services = await (userService, networkService, cacheService)","","        \/\/ 초기화 작업도 최적화됨","        await configureServices(services)","    }","}"],"syntax":"swift"},{"text":"컨텍스트 전환 최소화","anchor":"%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%A0%84%ED%99%98-%EC%B5%9C%EC%86%8C%ED%99%94","type":"heading","level":3},{"type":"codeListing","code":["class OptimizedViewController: UIViewController {","    override func viewDidLoad() {","        super.viewDidLoad()","","        Task { @MainActor in","            \/\/ ✅ MainActor 컨텍스트를 명시적으로 유지","            await setupUI()","        }","    }","","    @MainActor","    private func setupUI() async {","        \/\/ 모든 UI 관련 의존성이 MainActor에서 해결됨","        let uiService = await UnifiedDI.resolveAsync(UIService.self)","        let themeService = await UnifiedDI.resolveAsync(ThemeService.self)","        let analyticsService = await UnifiedDI.resolveAsync(AnalyticsService.self)","","        \/\/ UI 업데이트가 즉시 처리됨 (홉 없음)","        await uiService?.setupInterface()","        await themeService?.applyTheme()","        await analyticsService?.trackScreenView(\"main\")","    }","}"],"syntax":"swift"},{"text":"측정 및 프로파일링","anchor":"%EC%B8%A1%EC%A0%95-%EB%B0%8F-%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%A7%81","type":"heading","level":2},{"text":"성능 측정 도구","anchor":"%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95-%EB%8F%84%EA%B5%AC","type":"heading","level":3},{"type":"codeListing","code":["import os.signpost","","class PerformanceProfiler {","    static let logger = Logger(subsystem: \"DiContainer\", category: \"Performance\")","","    static func measureResolution<T>(_ type: T.Type,","                                   operation: () async -> T?) async -> T? {","        let signpost = OSSignpostID(log: logger)","        os_signpost(.begin, log: logger, name: \"Resolution\", signpostID: signpost)","","        let startTime = CFAbsoluteTimeGetCurrent()","        let result = await operation()","        let endTime = CFAbsoluteTimeGetCurrent()","","        os_signpost(.end, log: logger, name: \"Resolution\", signpostID: signpost)","","        print(\"해결 시간: \\((endTime - startTime) * 1000)ms\")","        return result","    }","}","","\/\/ 사용 예시","let service = await PerformanceProfiler.measureResolution(UserService.self) {","    await UnifiedDI.resolveAsync(UserService.self)","}"],"syntax":"swift"},{"text":"홉 카운터","anchor":"%ED%99%89-%EC%B9%B4%EC%9A%B4%ED%84%B0","type":"heading","level":3},{"type":"codeListing","code":["#if DEBUG","class HopCounter {","    private static var hopCount = 0","","    static func trackHop(from: String, to: String) {","        hopCount += 1","        print(\"Actor Hop #\\(hopCount): \\(from) → \\(to)\")","    }","","    static func resetCounter() {","        hopCount = 0","    }","","    static var currentHopCount: Int { hopCount }","}","#endif"],"syntax":"swift"},{"text":"모범 사례","anchor":"%EB%AA%A8%EB%B2%94-%EC%82%AC%EB%A1%80","type":"heading","level":2},{"text":"1. 적절한 API 선택","anchor":"1-%EC%A0%81%EC%A0%88%ED%95%9C-API-%EC%84%A0%ED%83%9D","type":"heading","level":3},{"type":"codeListing","code":["\/\/ ✅ 권장: 컨텍스트에 맞는 API 사용","@MainActor","class UIClass {","    func update() async {","        await UnifiedDI.resolveAsync(UIService.self) \/\/ MainActor 최적화","    }","}","","actor BackgroundActor {","    func process() async {","        await DIAsync.resolve(ProcessingService.self) \/\/ Actor 최적화","    }","}","","\/\/ ❌ 비권장: 컨텍스트 무시","class AnyClass {","    func doSomething() async {","        await DI.resolve(Service.self) \/\/ 최적화 기회 상실","    }","}"],"syntax":"swift"},{"text":"2. 의존성 그룹화","anchor":"2-%EC%9D%98%EC%A1%B4%EC%84%B1-%EA%B7%B8%EB%A3%B9%ED%99%94","type":"heading","level":3},{"type":"codeListing","code":["\/\/ ✅ 권장: 관련 의존성을 함께 해결","actor ServiceCoordinator {","    func initializeGroup() async {","        \/\/ 관련 서비스들을 한 번에 해결","        async let userService = DIAsync.resolve(UserService.self)","        async let authService = DIAsync.resolve(AuthService.self)","        async let profileService = DIAsync.resolve(ProfileService.self)","","        let services = await (userService, authService, profileService)","        \/\/ 그룹으로 초기화","        await configureUserModule(services)","    }","}"],"syntax":"swift"},{"text":"3. 지연 해결 피하기","anchor":"3-%EC%A7%80%EC%97%B0-%ED%95%B4%EA%B2%B0-%ED%94%BC%ED%95%98%EA%B8%B0","type":"heading","level":3},{"type":"codeListing","code":["\/\/ ✅ 권장: 초기화 시점에 해결","actor EagerResolver {","    private let services: (UserService?, NetworkService?)","","    init() async {","        \/\/ 생성 시점에 필요한 의존성 모두 해결","        self.services = await (","            DIAsync.resolve(UserService.self),","            DIAsync.resolve(NetworkService.self)","        )","    }","}","","\/\/ ❌ 비권장: 매번 해결","actor LazyResolver {","    func process() async {","        \/\/ 매번 홉이 발생할 수 있음","        let userService = await DIAsync.resolve(UserService.self)","        let networkService = await DIAsync.resolve(NetworkService.self)","    }","}"],"syntax":"swift"},{"text":"문제 해결","anchor":"%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0","type":"heading","level":2},{"text":"일반적인 성능 문제","anchor":"%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%84%B1%EB%8A%A5-%EB%AC%B8%EC%A0%9C","type":"heading","level":3},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"과도한 홉 발생","type":"text"}]}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ 문제: 여러 Actor 간 불필요한 전환","@MainActor func updateUI() async {","    let service = await someActor.getService() \/\/ 홉 1","    await anotherActor.processData(service)    \/\/ 홉 2","}","","\/\/ 해결: 단일 컨텍스트에서 처리","@MainActor func updateUI() async {","    let service = await UnifiedDI.resolveAsync(Service.self) \/\/ 홉 없음","    await processDataInMainActor(service)","}"],"type":"codeListing"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"동기\/비동기 혼용"}],"type":"strong"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ 문제: 동기 해결 후 비동기 작업","let service = DI.resolve(Service.self)      \/\/ 동기","await service?.processAsync()               \/\/ 비동기 전환","","\/\/ 해결: 일관된 비동기 패턴","let service = await UnifiedDI.resolveAsync(Service.self)","await service?.processAsync()"]}]}]},{"text":"다음 단계","anchor":"%EB%8B%A4%EC%9D%8C-%EB%8B%A8%EA%B3%84","type":"heading","level":2},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"doc:코어API"},{"type":"text","text":"에서 최적화된 API 사용법 상세 학습"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"doc:모듈시스템","type":"text"},{"text":"에서 모듈 레벨 최적화 적용","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"doc:프로퍼티래퍼"},{"type":"text","text":"에서 자동 최적화 활용"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"doc:플러그인시스템","type":"text"},{"text":"에서 커스텀 최적화 플러그인 개발","type":"text"}],"type":"paragraph"}]}]}],"kind":"content"}],"schemaVersion":{"major":0,"minor":3,"patch":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/DiContainer\/documentation\/DiContainer\/ActorHop"},"sections":[],"metadata":{"role":"article","modules":[{"name":"DiContainer"}],"roleHeading":"Article","title":"Actor Hop (KR)"},"hierarchy":{"paths":[["doc:\/\/DiContainer\/documentation\/DiContainer"]]},"abstract":[{"text":"DiContainer 2.0의 Actor Hop 최적화 기술로 Swift Concurrency에서 최대 성능을 달성하는 방법을 알아보세요.","type":"text"}],"references":{"doc://DiContainer/documentation/DiContainer":{"title":"DiContainer","kind":"symbol","url":"\/documentation\/dicontainer","role":"collection","type":"topic","abstract":[{"text":"A modern, high-performance dependency injection framework designed for Swift Concurrency and Actor models.","type":"text"}],"identifier":"doc:\/\/DiContainer\/documentation\/DiContainer"},"ActorHop.md":{"titleInlineContent":[{"type":"text","text":"Actor Hop"}],"type":"link","title":"Actor Hop","url":"ActorHop.md","identifier":"ActorHop.md"}}}