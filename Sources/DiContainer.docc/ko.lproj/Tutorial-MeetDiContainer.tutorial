@Tutorial(time: 25) {
  @Intro(title: "DiContainer 완전정복") {
    이 튜토리얼에서는 DiContainer의 모든 핵심 기능을 체계적으로 학습합니다.
    Property Wrapper부터 AppDIContainer까지, 실무에서 바로 사용할 수 있는 완전한 앱을 만들어보겠습니다.

    Counter 앱을 통해 @Inject, @Factory, @SafeInject의 차이점을 이해하고,
    AppDIContainer를 활용한 Clean Architecture를 구현해보겠습니다.
  }

  @Section(title: "기본 의존성 주입 이해하기") {
    @ContentAndMedia {
      Inject Property Wrapper를 사용하여 기본적인 의존성 주입을 구현합니다.
    }

    @Steps {
      @Step {
        먼저 카운터 앱의 기본 구조를 만들어보겠습니다.

        간단한 카운터 앱을 통해 DiContainer의 기본 개념을 이해해보겠습니다.

        @Code(name: "ContentView.swift", file: "Tutorial-MeetDiContainer-01-01.swift")
      }

      @Step {
        CounterService 프로토콜과 구현체를 정의합니다.

        비즈니스 로직을 분리하여 테스트하기 쉬운 구조를 만들겠습니다.

        @Code(name: "CounterService.swift", file: "Tutorial-MeetDiContainer-01-02.swift")
      }

      @Step {
        Inject를 사용하여 CounterService를 주입받습니다. Property Wrapper를 통해 의존성을 자동으로 주입받는 방법을 알아보겠습니다.

        @Code(name: "ContentView.swift", file: "Tutorial-MeetDiContainer-01-03.swift")
      }

      @Step {
        의존성을 등록하고 앱을 실행합니다.

        @Code(name: "App.swift", file: "Tutorial-MeetDiContainer-01-04.swift")
      }
    }
  }

  @Section(title: "Factory Pattern으로 새로운 인스턴스 생성") {
    @ContentAndMedia {
      Factory Property Wrapper를 사용하여 매번 새로운 인스턴스를 생성하는 방법을 학습합니다.
    }

    @Steps {
      @Step {
        로깅 서비스를 추가하여 Factory 패턴의 필요성을 이해합니다.

        매번 새로운 로그 세션이 필요한 상황을 만들어보겠습니다.

        @Code(name: "LoggingService.swift", file: "Tutorial-MeetDiContainer-02-01.swift")
      }

      @Step {
        Factory를 사용하여 로깅 서비스를 주입받습니다. Factory 패턴의 차이점을 명확히 이해해보겠습니다.

        @Code(name: "ContentView.swift", file: "Tutorial-MeetDiContainer-02-02.swift")
      }

      @Step {
        LoggingService를 등록하고 Factory와 Inject의 차이를 확인합니다.

        @Code(name: "App.swift", file: "Tutorial-MeetDiContainer-02-03.swift")
      }
    }
  }

  @Section(title: "안전한 의존성 주입 - SafeInject") {
    @ContentAndMedia {
      SafeInject를 사용하여 프로덕션 환경에서 안전하게 의존성을 처리하는 방법을 학습합니다.
    }

    @Steps {
      @Step {
        네트워크 서비스를 추가하여 실패할 수 있는 의존성을 만듭니다.

        안전한 에러 처리가 필요한 상황을 시뮬레이션해보겠습니다.

        @Code(name: "NetworkService.swift", file: "Tutorial-MeetDiContainer-03-01.swift")
      }

      @Step {
        SafeInject를 사용하여 안전하게 네트워크 서비스를 주입받습니다. 에러 처리와 함께 안전한 의존성 주입을 구현합니다.

        @Code(name: "ContentView.swift", file: "Tutorial-MeetDiContainer-03-02.swift")
      }

      @Step {
        의존성이 없을 때의 처리 방법을 확인합니다.

        SafeInject의 에러 처리 메커니즘을 테스트해보겠습니다.

        @Code(name: "App.swift", file: "Tutorial-MeetDiContainer-03-03.swift")
      }
    }
  }

  @Section(title: "AppDIContainer로 체계적인 의존성 관리") {
    @ContentAndMedia {
      AppDIContainer를 사용하여 Clean Architecture를 구현하고 체계적으로 의존성을 관리합니다.
    }

    @Steps {
      @Step {
        Repository 계층을 정의합니다.

        Clean Architecture의 Data Layer를 구현해보겠습니다.

        @Code(name: "CounterRepository.swift", file: "Tutorial-MeetDiContainer-04-01.swift")
      }

      @Step {
        UseCase 계층을 정의합니다.

        비즈니스 로직을 캡슐화하는 UseCase를 만들겠습니다.

        @Code(name: "CounterUseCase.swift", file: "Tutorial-MeetDiContainer-04-02.swift")
      }

      @Step {
        AppDIContainer를 설정하여 모든 의존성을 체계적으로 관리합니다.

        Clean Architecture의 모든 계층을 연결해보겠습니다.

        @Code(name: "App.swift", file: "Tutorial-MeetDiContainer-04-03.swift")
      }

      @Step {
        최종적으로 모든 Property Wrapper를 사용하는 완전한 뷰를 구현합니다. 이것만으로도 DiContainer의 기본적인 Clean Architecture 구현이 완료됩니다. 물론 아직 배워야 할 것들이 많이 있습니다. 실무 환경에서의 ModuleFactory 패턴, AutoDIOptimizer를 활용한 성능 최적화, 완전한 테스트 커버리지 구성 등이 있습니다. 하지만 지금은 여기서 멈추고 다음 섹션인 실무 환경 패턴으로 넘어가겠습니다.

        @Code(name: "ContentView.swift", file: "Tutorial-MeetDiContainer-04-04.swift")
      }
    }
  }

  @Section(title: "실무 환경: ModuleFactory 패턴") {
    @ContentAndMedia {
      실제 프로덕션 환경에서 사용하는 ModuleFactory 패턴과 체계적인 의존성 관리 방법을 학습합니다.
    }

    @Steps {
      @Step {
        ModuleFactoryManager를 구현합니다.

        여러 Factory들을 통합 관리하는 매니저를 만들어보겠습니다.

        @Code(name: "ModuleFactoryManager.swift", file: "Tutorial-MeetDiContainer-05-01.swift")
      }

      @Step {
        Repository와 UseCase Factory를 확장합니다.

        실무에서 사용하는 모듈별 Factory 패턴을 구현해보겠습니다.

        @Code(name: "FactoryExtensions.swift", file: "RTutorial-MeetDiContainer-05-02.swift")
      }

      @Step {
        AppDIContainer를 실무 방식으로 설정합니다.

        ModuleFactory를 활용한 체계적인 의존성 등록을 구현합니다.

        @Code(name: "AppDIContainer+Production.swift", file: "Tutorial-MeetDiContainer-05-03.swift")
      }

      @Step {
        AppDelegate에서 초기화를 설정합니다.

        실제 앱에서 사용하는 최적화와 부트스트랩 방식을 구현합니다.

        @Code(name: "AppDelegate.swift", file: "Tutorial-MeetDiContainer-05-04.swift")
      }
    }
  }

  @Section(title: "테스트와 Mock 객체") {
    @ContentAndMedia {
      DiContainer의 강력한 테스트 지원 기능을 활용하여 완전한 테스트 스위트를 작성합니다.
    }

    @Steps {
      @Step {
        Mock 객체들을 정의합니다.

        테스트를 위한 모든 Mock 구현체들을 만들어보겠습니다.

        @Code(name: "MockServices.swift", file: "Tutorial-MeetDiContainer-06-01.swift")
      }

      @Step {
        Property Wrapper별 테스트를 작성합니다.

        각 Property Wrapper의 특징을 검증하는 테스트들을 만들겠습니다.

        @Code(name: "PropertyWrapperTests.swift", file: "Tutorial-MeetDiContainer-06-02.swift")
      }

      @Step {
        ModuleFactory 패턴 테스트를 작성합니다.

        실무 환경의 Factory 패턴이 올바르게 동작하는지 검증합니다.

        @Code(name: "ModuleFactoryTests.swift", file: "Tutorial-MeetDiContainer-06-03.swift")
      }

      @Step {
        최종 앱을 실행하고 모든 기능을 확인합니다. 완성된 프로덕션 레벨 앱에서 ModuleFactory를 통한 체계적 의존성 관리, AutoDIOptimizer 최적화 활성화, Repository + UseCase Clean Architecture, AppDelegate 부트스트랩, 그리고 완전한 테스트 커버리지를 확인해보세요.
      }
    }
  }
}
